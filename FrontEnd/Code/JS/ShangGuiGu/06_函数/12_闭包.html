<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../../global/global.js"></script>
    <script>
        /*
            创建一个函数 第一次调用时打印1 第二次调用打印2 以此类推

            可以利用函数隐藏不希望被外部访问的变量

            闭包
                闭包就是能访问到外部函数作用域中变量的函数
                当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包
            闭包的构成
                函数的嵌套
                内部函数要引用外部函数中的变量
                内部函数要作为返回值返回
            闭包原理
                利用词法作用域
            闭包的生命周期
                闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
                在内部函数丢失时销毁(内部函数被垃圾回收了，闭包才会消失)
            注意事项
                闭包主要用来隐藏一些不希望被外部访问的内容 这就意味着闭包需要占用一定的内存空间
                相较于类来说 闭包比较浪费内存空间(类可以使用原型而闭包不能)
                需要执行次数较少时使用闭包 需要大量创建实例时使用类
        */
        function outer() {
            let num = 0
            return () => {
                num++
                console.log(num)
            }
        }
        const newFn = outer()
        /*
            不明白：为什么用newFn()调用num不会被重新赋值为0
            解释：num位于函数作用域内 outer返回的是()=>{num++ console.log(num)}
            ①function outer() {
                let num = 0
                return () => {
                    num++
                    console.log(num)
                }
            }
            实际上和
            ②let num = 0
            function outer(){
                num++
                console.log(num)
            }
            在结构和作用域上是大致相同的
            但是②中的num是一个全局变量 全局变量有可能不小心被修改
            
        */
        newFn()//outer返回的是()=>{num++ console.log(num)}
        _()

        let a = "全局变量a"
        /*
            函数的外层作用域在函数创建时就已经确定了(词法作用域)和调用的位置无关
        */
        function fn() {
            console.log(a);
        }
        function fn2() {
            let a = "fn2中的a"
            fn()
        }
        fn2()
        _()
        function fn3() {
            let a = "fn3中的a"
            function fn4() {
                console.log(a)
            }
            return fn4
        }
        let fn4 = fn3()
        fn4()
        _()

        function outCloser() {
            let outCloserVariable = "This variable is in the outCloser"
            return function () {
                console.log(outCloserVariable)
            }
        }
        const outCloserFn = outCloser() //独立闭包
        const outCloserFn2 = outCloser()//独立闭包
        outCloserFn()
        outCloserFn2()
    </script>
</head>

<body>

</body>

</html>
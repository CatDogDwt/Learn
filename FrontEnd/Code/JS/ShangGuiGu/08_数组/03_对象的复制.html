<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>对象的复制</title>
    <script src="../../global/global.js"></script>
    <script>
        _begin()
        /*
            如果对象中存储的数据是原始值，那么拷贝的深浅不重要
                浅拷贝(shallow copy)：
                    通常对对象的拷贝都是浅拷贝
                    浅拷贝只对对象的本身进行复制，不会复制对象中的属性或元素(只复制一层)

                深拷贝(deep copy):
                    深拷贝不仅复制对象本身 还会复制对象中的属性或元素
                    因为性能问题 通常情况下不太使用深拷贝

            slice()方法以新的数组对象，返回数组中被选中的元素。
            slice(start,end)方法选择从给定的 start 参数开始的元素，并在给定的 end 参数处结束，但不包括。
                slice()方法不会改变原始数组。
        */
        const arr = [{ name: "Ming" }, { name: "Tao" }]
        console.log(arr)
        _()
        //浅拷贝
        const arr2 = arr
        console.log(arr2)
        console.log("arr?arr2", arr === arr2)
        const arr3 = arr.slice()
        console.log(arr3)
        console.log("arr?arr3", arr === arr3)
        _()
        //深拷贝
        const arr4 = structuredClone(arr)
        console.log(arr4)
        console.log("arr?arr4", arr === arr4)
        arr[0].name = "Min"
        console.log("arr[0].name = Min--->", arr)//浅拷贝是一种引用 所以最初的被拷贝对象里的值被改变 拷贝对象的值也会被改变
        console.log("arr[0].name = Min--->", arr2)
        console.log("arr[0].name = Min--->", arr3)
        console.log("arr[0].name = Min--->", arr4)//深拷贝会将被拷贝对象里的属性和元素 拷贝到一个新的对象中
        const obj = {
            role1: "Eren",
            friend: {
                rf1: "Mikasa"
            }
        }
        console.log("obj--->", obj);
        //对obj进行浅复制
        const obj2 = Object.assign({}, obj);
        console.log("obj2--->", obj2, "obj.friend=obj2.friend?", obj2.friend === obj.friend);
        //深复制
        const obj3 = structuredClone(obj);
        console.log("obj3--->", obj3, "obj.friend=obj3.friend?", obj3.friend === obj.friend);
        _()
        /*
            复制的方式：
                ...
                    展开运算符 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递（浅拷贝）
                              可以将一个对象中的属性展开到另一个对象中或者作为函数的参数传递（浅拷贝）
                              ......
                Object.assign(目标对象,被复制的对象)
                    将被复制对象中的属性复制到目标对象里，并将目标对象返回
        */
        const arr5 = [...arr]
        console.log(arr5)
        console.log("arr?arr5", arr === arr5);
        const obj4 = { obj4: "obj4" };
        const obj5 = Object.assign({}, obj4)
        console.log(obj5)

         
    </script>
</head>

<body>

</body>

</html>
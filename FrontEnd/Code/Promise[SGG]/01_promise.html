<!--
 Promise是JS中进行异步编程的新解决方案(ES6规范引入 旧方案是回调函数)
      异步编程：FS文件操作、数据库操作、Ajax、定时器
 从语法上来说 promise是一个构造函数
 从功能上来说 promise对象用来封装一个异步操作并可以获取其成功/失败的结果
 promise状态
    实例对象中有一个属性 【PromiseState】有三个值 pending 未决定的 resolved/fullfilled 已解决的 rejected 未解决的
    promise状态变化只有两种可能
        pending变为resolved/fullfilled
        pending变为rejected
    且一个promise对象只能改变一次 无论变为成功还是失败 都会有一个结果数据 成功的结果称为value 失败称为reason
 优点
      指定回调函数的方式更加灵活 旧的回调函数必须在启动异步任务前指定
      promise：启动异步任务--👉返回promise对象--👉给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)
      支持链式调用 可以解决回调地狱问题
          回调地狱：回调函数嵌套调用 外部回调函数异步执行的结果是嵌套的回调执行的条件 不便于阅读和异常处理 解决方式为promise链式调用
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初体验</title>
</head>

<body>
    <h1>Promise初体验</h1>
    <hr>
    <button id="btn">点击抽奖(普通版)</button>
    <button id="btnn">点击抽奖(Promise版)</button>
    <script>
        //生成随机数
        function rand(m, n) {
            return Math.ceil(Math.random() * (n - m + 1)) + m - 1;
        }
        //点击按钮 2s后显示是否中奖(30%概率) 若中奖弹出：恭喜中奖 如未中奖 则弹出 再接再厉
        ////不使用promise
        btn.addEventListener('click', () => {
            //30%中奖概率
            setTimeout(() => {
                let n = rand(1, 100);
                if (n <= 30) {
                    alert('恭喜中奖')
                } else {
                    alert('再接再厉')
                }
            }, 2000);
        })
        ////使用promise
        btnn.addEventListener('click', () => {
            const p = new Promise((resolve, reject) => {//构造函数实例化 接受两个参数resolve解决和reject拒绝 都是函数类型的数据 当异步任务成功是调用resolve 当失败时调用reject
                //30%中奖概率
                setTimeout(() => {
                    let n = rand(1, 100);
                    if (n <= 30) {
                        resolve(n);//可以将promise对象的状态设置为成功
                    } else {
                        reject(n);//可以将promise对象的状态设置为失败
                    }
                }, 2000);
            })
            //调用then方法 接受两个函数类型参数 第一个参数为函数成功时的回调 第二个参数为函数失败时的回调
            p.then((value) => {
                alert('恭喜中奖' + value)
            }, (reason) => {
                alert('再接再厉' + reason)
            })
        })
    </script>
</body>

</html>